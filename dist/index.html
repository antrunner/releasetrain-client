<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>releasetrain.io</title>
    <link href="img/favicon.ico" rel="icon" type="image/x-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Software Component Version Releases" />
    <meta name="keywords" content="Version, Release, Agile" />
    <meta name="author" content="Solomon Berhe" />
    <meta name="google-site-verification" content="e_DoTsZw_SlkIWfECBN2q7FkJBvy8xOvlQZ-ZL38xTk" />
    <meta http-equiv="refresh" content="3600" />
    <link href="./reset.css" rel="stylesheet" />
    <link href="./lib/select2.min.css" rel="stylesheet" />
    <link href="./app.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" rel="stylesheet" />
    <script type="module" src="./app.js" defer></script>
    <script src="https://cjrtnc.leaningtech.com/2.3/loader.js"></script>
</head>

<body>

    <!-- Top Bar -->
    <div class="top-bar">

        <!-- Dropdown Select (styled for better alignment) -->
        <select class="component-names" name="names[]" multiple="multiple"></select>

        <!-- Info Bar (aligned horizontally) -->
        <div class="info-bar">

            <span style="color: #888;">Releasetrain <span style="color: #4da6ff;">v3.1.0</span></span>

            <span class="getComponentCount" style="color: #999;">Components:
                <span style="color: #4da6ff;">Loading...</span>
            </span>

            <span class="getVersionCount" style="color: #999;">Versions:
                <span style="color: #4da6ff;">Loading...</span>
            </span>

            <span class="getRedditCount" style="color: #999;">Reddit:
                <span style="color: #4da6ff;">Loading...</span>
            </span>

            <span class="currentPageVersions" style="color: #999;">Page Versions:
                <span style="color: #4da6ff;">0</span>
            </span>

            <span class="dateRangeLabel" style="color: #888;"></span>

            <!-- Discord link with matching styling -->
            <!-- <span>
                <a href="https://discord.gg/mMruEzZe" target="_blank" style="
            color: #4da6ff;
            text-decoration: none;
            font-weight: bold;
        ">
                    Discord ‚Üó
                </a>
            </span> -->

            <span>
                <a href="https://github.com/antrunner/releasetrain-client" target="_blank" style="
            color: #4da6ff;
            text-decoration: none;
            font-weight: bold;
        ">
                    GitHub ‚Üó
                </a>
            </span>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">

        <!-- Left Column: Realtime Feed -->
        <div class="left-column">

            <!-- Sorting Buttons -->
            <div class="sort-buttons">
                <button id="sortByTriageLastUpdate" class="btn-dark active">Recent Updates</button>
                <button id="sortByTriageBreaking" class="btn-dark">Failure Impact</button>
                <button id="sortByTriageSecurity" class="btn-dark">Security Impact</button>
                <button id="sortByTriageLegal" class="btn-dark">Legal Impact</button>
            </div>

            <hr noshade="no">

            <div class="content">
                <div class="loadingClass">
                    <img src="./img/spinner.gif" alt="Loading..." />
                </div>
                <ol class="versionListClassSection"></ol>
                <div class="errorHandling"></div>
            </div>
        </div>

        <!-- Second Column: Graphs -->
        <div class="graph-column">
            <section id="graphSection1">
                <canvas id="graphCanvas"></canvas>
                <canvas id="componentTypeChart"></canvas>
            </section>
        </div>
        <!-- Third Column: Graphs -->
        <div class="graph-column">
            <section id="graphSection2">
                <canvas id="updateTypeChart"></canvas>
                <canvas id="cveChart"></canvas>
            </section>
        </div>
        <!-- Fourth Column: Chat -->
        <div class="chat-column">
            <section id="llmChatSection">
                <div id="chatWindow">
                    <!-- Chat messages appear here -->
                    <div style="color: #888; text-align: center;">Ask about software updates...</div>
                </div>
                <div style="display: flex; align-items: center; padding-top: 4px;">
                    <input type="text" id="chatInput" placeholder="Ask about updates...">
                    <button id="sendChat">‚û§</button>
                </div>
            </section>
        </div>
    </div>


    <div class="canvas-container">
        <canvas id="plantuml-diagrams"></canvas>
    </div>

    <!-- Scripts -->
    <script src="https://www.googletagmanager.com/gtag/js?id=UA-79349402-1" async></script>
    <script src="./lib/googleanalytics.js"></script>
    <script src="./lib/jquery-2.2.4.min.js"></script>
    <script src="./lib/select2.min.js"></script>
    <!-- Chart.js for Graphing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.bundle.min.js"></script>
    <!-- Mermaid.js for UML Diagrams (if needed elsewhere) -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script type="text/javascript">
        // Initialize Mermaid for UML rendering (if used)
        mermaid.initialize({ startOnLoad: true });

        // üîπ Global storage for Reddit posts
        let globalRedditPosts = [];
        let redditPostCounts = {};
        let versionData = []; // Global variable to store version data

        let cachedTriageBreakingData = null; // Store sorted results specific to TriageBreaking
        let cachedTriageSecurityData = null; // Store sorted results specific to TriageSecurity
        let cachedTriageLastUpdateData = null; // Store sorted results specific to LastUpdate
        let cachedTriageLegalData = null;

        // Precompute Reddit post counts when the page loads
        function computeRedditPostCounts() {
            redditPostCounts = globalRedditPosts.reduce((acc, post) => {
                let subreddit = post.subreddit || "";
                acc[subreddit] = (acc[subreddit] || 0) + 1; // Count posts per subreddit
                return acc;
            }, {});
        }

        // Define helper functions first
        function isSameDate(d1, d2) {
            return d1.getFullYear() === d2.getFullYear() &&
                d1.getMonth() === d2.getMonth() &&
                d1.getDate() === d2.getDate();
        }

        function formatDate(d) {
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const today = new Date();
            const yesterday = new Date();
            yesterday.setDate(today.getDate() - 1);

            const releaseDate = new Date(`${d.slice(0, 4)}-${d.slice(4, 6)}-${d.slice(6, 8)}`);

            if (isNaN(releaseDate.getTime())) {
                return null;
            }

            if (isSameDate(releaseDate, today)) {
                return "Today";
            } else if (isSameDate(releaseDate, yesterday)) {
                return "Yesterday";
            } else {
                return `${months[releaseDate.getMonth()]} ${releaseDate.getDate()}, ${releaseDate.getFullYear()}`;
            }
        }

        // ==========================
        // Existing Feed Code (Endpoints preserved)
        // ==========================
        const apiBaseUrl = "https://releasetrain.io/api";
        let componentNameParam = "";
        let stack_name = "";
        let currDate = null;
        let countToday = 0;
        let isDone = false;

        const loader = $('.loadingClass');
        $.ajaxSetup({
            beforeSend: () => loader.show(),
            complete: () => loader.hide()
        });

        $('.component-names').on("change", function () {
            componentNameParam = $(this).select2('data').map(item => item.text).join(',');
            updateURLWithSelectedComponents();
            if (isDone) {
                if (componentNameParam === new URLSearchParams(window.location.search).get('q')) {
                    getReleases();
                } else {
                    window.location.href = `https://releasetrain.io?q=${componentNameParam}`;
                }
            }
        });

        function updateURLWithSelectedComponents() {
            const selectedComponents = $('.component-names').select2('data').map(item => item.text).join(',');
            window.history.replaceState({}, document.title, `?q=${selectedComponents}`);
        }


        function checkIfStackExists(stack_name) {
            console.log(stack_name);

            if (stack_name === "lamp") {
                return "LAMP"

            }
            else {
                return "Not Found"
            }
        }

        function getAndRenderComponentList() {
            $('.component-names').select2({
                tags: true,
                multiple: true,
                tokenSeparators: [',', ' '],
                minimumInputLength: 0,  // Show results immediately
                minimumResultsForSearch: 1, // Allow searching quickly
                ajax: {
                    url: `${apiBaseUrl}/c/names`,
                    dataType: "json",
                    type: "GET",
                    delay: 100, // Reduce delay for faster response
                    cache: true, // Cache results to avoid redundant queries
                    data: params => ({ term: params.term }),
                    processResults: data => ({
                        results: data.map(item => ({
                            text: item.versionProductName,
                            id: item.versionProductName
                        }))
                    })
                }
            });
        }

        function getAvatarHtml(versionProductName, isCve, isSecurityPatch, versionUrl, initialAvatar) {
            const productName = versionProductName.toLowerCase();
            const productAvatars = {
                "chrome": "./img/Google-Chrome-Chromium-icon.png",
                "ledvance": "./img/ledvance.png",
                "firefox": "./img/firefox.png",
                "android studio": "./img/androidStudio.png",
                "safari": "./img/safari.png",
                "eclipse": "./img/eclipse.png",
                "let's encrypt": "./img/letsencrypt.png",
                "vmware": "./img/vmware.png",
                "oracle": "./img/vboracle.png"
            };

            if (productAvatars[productName]) {
                return `<img class="avatar" src="${productAvatars[productName]}" alt="${versionProductName}">`;
            }

            if (productName === "digitalocean") {
                return '<i class="fas fa-exclamation-triangle"></i>';
            }

            // Show an exclamation mark if the URL is NVD
            if (versionUrl && versionUrl.startsWith("https://nvd.nist.gov/")) {
                return '<img class="avatar" src="./img/cve.png" alt="CVE">';
            }

            // GitHub avatar always wins
            if (versionUrl && versionUrl.includes("github.com/")) {
                return `<img class="avatar" src="https://github.com/${versionUrl.split('/')[3]}.png" alt="${versionProductName}">`;
            }

            // Handle generic git-based avatars
            if (versionUrl && versionUrl.startsWith("https://git")) {
                return `<img class="avatar" src="${versionUrl}.png" alt="${versionProductName}">`;
            }

            return `<img class="avatar" src="./img/default.png" alt="${versionProductName}">`;
        }

        function drawTimeSeriesChart(data) {
            const canvas = document.getElementById('graphCanvas');
            if (!canvas) {
                console.error("Canvas element with id 'graphCanvas' not found.");
                return;
            }

            // Ensure the canvas fills its container
            canvas.height = 250;
            const ctx = canvas.getContext('2d');

            // ‚úÖ Convert date labels to "Mon, Feb 25" format
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

            // ‚úÖ Ensure the labels are properly formatted
            let formattedLabels = data.labels.map(label => {

                if (label === "Today" || label === "Yesterday") return label;

                // Convert from YYYY-MM-DD to Date object safely
                let year = label.slice(0, 4);
                let month = label.slice(4, 6) - 1; // Months are zero-based in JavaScript (0 = January)
                let day = label.slice(6, 8);

                // Ensure values are valid before creating the Date object
                if (isNaN(year) || isNaN(month) || isNaN(day)) {
                    console.warn(`Invalid date detected: ${label}`);
                    return label; // Return raw label if invalid
                }

                let dateObj = new Date(year, month, day);

                if (isNaN(dateObj.getTime())) {
                    console.warn(`Invalid date detected: ${label}`);
                    return label; // Return raw label if invalid
                }

                return `${dayNames[dateObj.getDay()]}, ${monthNames[dateObj.getMonth()]} ${dateObj.getDate()}`;
            });

            // ‚úÖ Ensure at least 7 days of data (fill missing days with 0)
            if (formattedLabels.length < 7) {
                console.warn("Less than 7 days of data detected. Filling missing days...");

                let today = new Date();
                let last7Days = [];

                for (let i = 6; i >= 0; i--) {
                    let date = new Date();
                    date.setDate(today.getDate() - i);
                    let formattedDate = `${dayNames[date.getDay()]}, ${monthNames[date.getMonth()]} ${date.getDate()}`;

                    last7Days.push(formattedDate);
                }

                formattedLabels = last7Days; // Replace with full 7 days
            }

            new Chart(ctx, {
                type: 'bar', // Changed from 'line' to 'bar'
                data: {
                    labels: formattedLabels, // ‚úÖ Use formatted labels
                    datasets: [{
                        label: 'Updates 7 Days',
                        data: data.counts,
                        backgroundColor: 'rgba(75, 192, 192, 0.4)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1,
                        fill: true,
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    scales: {
                        xAxes: [{
                            ticks: {
                                autoSkip: true,
                                maxTicksLimit: 10,
                                fontColor: "#d1d5db",
                                callback: function (value) {
                                    return value; // Ensure proper date formatting
                                }
                            },
                            gridLines: {
                                color: "#444"
                            }
                        }],
                        yAxes: [{
                            ticks: {
                                beginAtZero: true,
                                fontColor: "#d1d5db"
                            },
                            gridLines: {
                                color: "#444"
                            }
                        }]
                    },
                    legend: {
                        labels: {
                            fontColor: "#d1d5db"
                        }
                    }
                }
            });
        }

        function drawComponentTypeChart(data) {
            const canvas = document.getElementById('componentTypeChart');
            if (!canvas) {
                console.error("Canvas element with id 'componentTypeChart' not found.");
                return;
            }

            const ctx = canvas.getContext('2d');
            canvas.height = 250;

            const labels = Object.keys(data);
            const counts = Object.values(data);

            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Component Type Counts',
                        data: counts,
                        backgroundColor: 'rgba(153, 102, 255, 0.6)',
                        borderColor: 'rgba(153, 102, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    scales: {
                        xAxes: [{
                            ticks: {
                                fontColor: "#d1d5db"
                            },
                            gridLines: {
                                color: "#444"
                            }
                        }],
                        yAxes: [{
                            ticks: {
                                beginAtZero: true,
                                fontColor: "#d1d5db"
                            },
                            gridLines: {
                                color: "#444"
                            }
                        }]
                    },
                    legend: {
                        labels: {
                            fontColor: "#d1d5db"
                        }
                    }
                }
            });
        }

        function getVersionForecast(component) {

            console.warn("Disabled version forecast for component:", component);
            return;

            $.ajax({
                url: `${apiBaseUrl}/v/fc?q=${component}`,
                type: 'GET',
                dataType: 'json',
                success: res => {
                    if (res && res.nextReleaseDate) {
                        $(".rt-class-" + component).text(`Next ${component} update estimation on ${res.nextReleaseDate}`);
                        if (componentNameParam.split(",").length > 1) {
                            getCoincideForecast(component);
                        }
                    } else {
                        $(".rt-class-" + component).text(""); // Set empty string if no data
                    }
                },
                error: error => {
                    console.error(`Error fetching version forecast for ${component}:`, error);
                    $(".rt-class-" + component).text(""); // Set empty string on error
                }
            });
        }

        function getCoincideForecast(component) {

            console.warn("Disabled version coincide for component:", component);
            return;

            $.ajax({
                url: `${apiBaseUrl}/v/fcc?q=${componentNameParam}`,
                type: 'GET',
                dataType: 'json',
                success: res => {
                    if (res && res.isCoincideReleaseDate && Array.isArray(res.components) && res.components.includes(component)) {
                        res.components = res.components.filter(item => item !== component);
                        const msg = res.components.length > 0
                            ? `may coincide with a ${res.components.join(" and ")} update.`
                            : ""; // Set empty string if no other components

                        if (!$(`.${component}`).text().includes(msg)) {
                            $(`.${component}`).html(`<b>${msg}</b>`);
                        }
                    } else {
                        $(`.${component}`).text(""); // Set empty string if no valid data
                    }
                },
                error: error => {
                    console.error(`Error fetching coincide forecast for ${component}:`, error);
                    $(`.${component}`).text(""); // Set empty string on error
                }
            });
        }

        // ‚úÖ Fetch version count
        function getVersionCount() {
            $.ajax({
                url: `${apiBaseUrl}/v/count`,
                type: 'GET',
                dataType: 'json',
                success: res => {
                    if (res.totalVersions !== undefined) {
                        $(".getVersionCount").text(`Versions: ${res.totalVersions}`);
                    } else {
                        console.warn('Unexpected response structure for version count:', res);
                        $(".getVersionCount").text(`Versions: N/A`);
                    }
                },
                error: error => {
                    console.error('Error fetching version count:', error);
                    $(".getVersionCount").text(`Versions: Error`);
                }
            });
        }

        // ‚úÖ Fetch reddit count
        function getRedditCount() {
            $.ajax({
                url: `${apiBaseUrl}/reddit/count`,
                type: 'GET',
                dataType: 'json',
                success: res => {
                    if (res.totalRedditPosts !== undefined) {
                        $(".getRedditCount").text(`Reddit: ${res.totalRedditPosts}`);
                    } else {
                        console.warn('Unexpected response structure for version count:', res);
                        $(".getRedditCount").text(`Reddit: N/A`);
                    }
                },
                error: error => {
                    console.error('Error fetching version count:', error);
                    $(".getRedditCount").text(`Reddit: Error`);
                }
            });
        }

        // ‚úÖ Fetch component count
        function getComponentCount() {
            $.ajax({
                url: `${apiBaseUrl}/c/count`,
                type: 'GET',
                dataType: 'json',
                success: res => {
                    if (res.totalComponents !== undefined) {
                        $(".getComponentCount").text(`Components: ${res.totalComponents}`);
                    } else {
                        console.warn('Unexpected response structure for component count:', res);
                        $(".getComponentCount").text(`Components: N/A`);
                    }
                },
                error: error => {
                    console.error('Error fetching component count:', error);
                    $(".getComponentCount").text(`Components: Error`);
                }
            });
        }

        function isNewerThanDayAfterTomorrow(dateString) {
            const year = parseInt(dateString.substring(0, 4));
            const month = parseInt(dateString.substring(4, 6)) - 1;
            const day = parseInt(dateString.substring(6, 8));
            const specificDate = new Date(year, month, day);
            const today = new Date();
            const dayAfterTomorrow = new Date(today.getFullYear(), today.getMonth(), today.getDate() + 2);
            return specificDate > dayAfterTomorrow;
        }

        function isSameDate(d1, d2) {
            return d1.getFullYear() === d2.getFullYear() &&
                d1.getMonth() === d2.getMonth() &&
                d1.getDate() === d2.getDate();
        }

        function drawUpdateTypeChart(data, dateRange) {
            const canvasId = "updateTypeChart";

            // Calculate total updates
            const totalUpdates = data.major + data.other + data.minor + data.patch;

            // Remove existing canvas if present (to allow re-rendering)
            $("#" + canvasId).remove();
            $("#graphSection2").append(`<canvas id="${canvasId}"></canvas>`);

            const ctx = document.getElementById(canvasId).getContext("2d");

            document.getElementById(canvasId).height = 250;

            new Chart(ctx, {
                type: "bar",
                data: {
                    labels: ["Major Updates", "Other Updates", "Minor Updates", "Patch Updates"],
                    datasets: [{
                        label: `Update Type Count`, // üè∑Ô∏è Added total updates & date range
                        data: [data.major, data.other, data.minor, data.patch],
                        backgroundColor: ["#4da6ff", "#ca4141", "#47863e", "#ffbd2e"],
                        borderColor: ["#2b7cd3", "#8b2e2e", "#2b5d29", "#c98c1e"],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    scales: {
                        yAxes: [{
                            ticks: {
                                beginAtZero: true,
                                fontColor: "#d1d5db"
                            },
                            gridLines: {
                                color: "#444"
                            }
                        }],
                        xAxes: [{
                            ticks: {
                                fontColor: "#d1d5db"
                            },
                            gridLines: {
                                color: "#444"
                            }
                        }]
                    },
                    legend: {
                        labels: {
                            fontColor: "#d1d5db"
                        }
                    }
                }
            });
        }

        function drawPlantuml() {
            const canvasId = "plantuml";

            // Remove existing canvas if present (to allow re-rendering)
            $("#" + canvasId).remove();
            $("#graphSection1").append(`<canvas id="${canvasId}"></canvas>`);

            const ctx = document.getElementById(canvasId).getContext("2d");

            document.getElementById(canvasId).height = 250;
            const image = new Image();


            image.addEventListener("load", (e) => {
                ctx.drawImage(image, 10, 10);
            });
            image.src = "https://hatrabbits.com/wp-content/uploads/2017/01/random.jpg";
        }
        // Function to count different update types and render the bar chart
        function processUpdateTypeCounts(res) {
            let updateCounts = { major: 0, other: 0, minor: 0, patch: 0 };
            let updateDates = []; // To store valid dates in sortable `YYYYMMDD` format
            let componentTypeCounts = {}; // To store counts of each component type
            let cveCounts = { cve: 0, other: 0 };

            res.forEach(item => {
                // Count update types
                switch (item.versionReleaseChannel) {
                    case "major":
                        updateCounts.major++;
                        break;
                    case "minor":
                        updateCounts.minor++;
                        break;
                    case "patch":
                        updateCounts.patch++;
                        break;
                    default:
                        updateCounts.other++;
                        break;
                }

                // Count component types
                if (item.versionPredictedComponentType) {
                    componentTypeCounts[item.versionPredictedComponentType] = (componentTypeCounts[item.versionPredictedComponentType] || 0) + 1;
                }

                // Extract valid dates (YYYYMMDD format)
                if (item.versionReleaseDate) {
                    updateDates.push(item.versionReleaseDate); // Store directly as `YYYYMMDD` string
                }

                if (item.isCve) {
                    cveCounts.cve++;
                } else {
                    cveCounts.other++;
                }
            });

            // Sort dates in ascending order (YYYYMMDD is already sortable as a string)
            updateDates.sort();

            // Get today's and yesterday's dates in `YYYYMMDD` format
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0].replace(/-/g, ""); // Format YYYYMMDD
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toISOString().split('T')[0].replace(/-/g, "");

            // Get the formatted date range
            let dateRange = "N/A";
            if (updateDates.length > 0) {
                let startDate = formatDate(updateDates[0]); // Earliest date
                let endDateRaw = updateDates[updateDates.length - 1]; // Latest date in `YYYYMMDD`
                // Convert end date to "Today" or "Yesterday" if applicable
                let endDate = formatDate(endDateRaw);
                dateRange = `${startDate} - ${endDate}`;
            }

            // Update the date range label in the info-bar
            $(".dateRangeLabel").text(`Date Range: ${dateRange}`);

            // üè∑Ô∏è Pass `dateRange` to the update chart function
            drawUpdateTypeChart(updateCounts, dateRange);

            // üè∑Ô∏è Draw the component type chart
            drawComponentTypeChart(componentTypeCounts);

            // üè∑Ô∏è Draw the CVE chart
            drawCveChart(cveCounts);
        }

        async function getReleases() {
            $(".versionListClassSection").empty();

            try {
                versionData = await getVersionList(); // ‚úÖ Fetch versions first

                await getAllRedditPosts(); // ‚úÖ Then fetch Reddit posts

                renderVersionList(versionData); // ‚úÖ Finally, render everything

            } catch (error) {
                console.error("[ERROR] Failed in getReleases():", error);
            }
        }

        // ‚úÖ Ensure getVersionList() returns a Promise
        function getVersionList() {
            const requestUrl = `${apiBaseUrl}/v?q=${componentNameParam}`;

            return new Promise((resolve, reject) => {
                $.ajax({
                    url: requestUrl,
                    type: 'GET',
                    dataType: 'json',
                    success: function (data) {
                        const versionCount = data.versions ? data.versions.length : 0;

                        // ‚úÖ Update "Page Versions" count dynamically
                        document.querySelector(".currentPageVersions span").textContent = versionCount;

                        resolve(data.versions || []); // ‚úÖ Always return an array (default empty)
                    },
                    error: (xhr, status, error) => {
                        console.error(`[ERROR] Fetching version list: ${error}`);
                        console.warn(`[Response] Status: ${status}, URL: ${requestUrl}, Response:`, xhr.responseText);
                        reject(error); // ‚ùå Reject if AJAX fails
                    }
                });
            });
        }

        /**
         * üîπ Fetch all Reddit posts from the last 10 days and store them globally.
         */
        function getAllRedditPosts() {
            return new Promise((resolve, reject) => {
                $.ajax({
                    url: `${apiBaseUrl}/reddit`, // Fetch latest 10 days of Reddit posts
                    type: 'GET',
                    dataType: 'json',
                    success: redditPosts => {
                        if (!Array.isArray(redditPosts) || redditPosts.length === 0) {
                            globalRedditPosts = [];
                            return resolve();
                        }

                        globalRedditPosts = redditPosts; // ‚úÖ Store fetched posts globally
                        resolve();
                    },
                    error: error => {
                        console.error("[REDDIT] Error fetching posts:", error);
                        globalRedditPosts = [];
                        reject(error);
                    }
                });
            });
        }

        // Convert UTC timestamp to "X days ago" format
        function timeAgo(utcTimestamp) {
            const postDate = new Date(utcTimestamp); // Convert to milliseconds
            const today = new Date();
            const diffTime = Math.abs(today - postDate);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

            return diffDays === 0 ? "Today" : diffDays === 1 ? "Yesterday" : `${diffDays} days ago`;
        }

        /**
         * üîπ Render version list and include Reddit posts if subreddit matches version name.
         * üîπ Updates four charts: Update Type, Component Type, Time Series, and CVE.
         */
        function renderVersionList(res) {
            countToday = 0;
            let dailyCounts = {};
            let groupedVersions = {};
            let updateCounts = { major: 0, other: 0, minor: 0, patch: 0 };
            let componentTypeCounts = {};
            let cveCounts = { cve: 0, other: 0 };

            const today = new Date();
            const currentYear = today.getFullYear();
            const yesterday = new Date();
            yesterday.setDate(today.getDate() - 1);
            let oneWeekAgo = new Date();
            oneWeekAgo.setDate(today.getDate() - 7);

            if (res.length === 0) {
                $(".errorHandling").html("No results found.");
            } else {
                $(".errorHandling").empty();
            }

            $(".versionListClassSection").empty();
            let firstOpenFound = false;

            res.forEach(item => {
                try {
                    let releaseDate = new Date(
                        item.versionReleaseDate.slice(0, 4),
                        parseInt(item.versionReleaseDate.slice(4, 6)) - 1,
                        parseInt(item.versionReleaseDate.slice(6, 8))
                    );

                    if (isNaN(releaseDate.getTime()) || releaseDate > today) return;

                    let formattedDate = releaseDate.toDateString() === today.toDateString() ? "Today" :
                        releaseDate.toDateString() === yesterday.toDateString() ? "Yesterday" :
                            `${releaseDate.toDateString()}`;

                    if (!groupedVersions[formattedDate]) {
                        groupedVersions[formattedDate] = [];
                    }
                    groupedVersions[formattedDate].push(item);

                    // ‚úÖ Collect data for charts
                    if (releaseDate >= oneWeekAgo) {
                        let yyyymmdd = releaseDate.toISOString().split("T")[0].replace(/-/g, "");
                        dailyCounts[yyyymmdd] = (dailyCounts[yyyymmdd] || 0) + 1;
                    }

                    if (item.versionReleaseChannel) {
                        updateCounts[item.versionReleaseChannel] = (updateCounts[item.versionReleaseChannel] || 0) + 1;
                    }

                    if (item.classification && Array.isArray(item.classification.componentType) && item.classification.componentType.length > 0) {
                        item.classification.componentType.forEach(predictedType => {
                            componentTypeCounts[predictedType] = (componentTypeCounts[predictedType] || 0) + 1;
                        });
                    } else {
                        componentTypeCounts["Not Typed"] = (componentTypeCounts["Not Typed"] || 0) + 1;
                    }


                    if (item.isCve) {
                        cveCounts.cve++;
                    } else {
                        cveCounts.other++;
                    }

                } catch (error) {
                    console.error("[ERROR] Failed to process version:", item, error);
                }
            });

            let sortedDates = Object.keys(groupedVersions).sort((a, b) => {
                if (a === "Today") return -1;
                if (b === "Today") return 1;
                if (a === "Yesterday") return -1;
                if (b === "Yesterday") return 1;
                return new Date(b) - new Date(a);
            });

            let htmlBuffer = ""; // ‚úÖ Efficient UI rendering with buffer

            sortedDates.forEach((date) => {
                let updatesCount = groupedVersions[date].length;
                let isOpen = !firstOpenFound && updatesCount > 0 ? "open" : "";
                if (updatesCount > 0) {
                    firstOpenFound = true;
                }

                htmlBuffer += `
        <details ${isOpen}>
            <summary><b>${date}</b> (${updatesCount} updates)</summary>
            <ul class="versionList">`;

                groupedVersions[date].forEach(item => {
                    const avatar = getAvatarHtml(item.versionProductName, false, item.versionReleaseChannel === "patch", item.versionUrl, item.versionProductType);
                    const versionLabel = `${item.versionProductName.substring(0, 20)}`;


                    let tags = "";

                    // ‚úÖ Wrap everything in a single row layout
                    tags += `<div style="display: flex; flex-wrap: wrap; align-items: center; gap: 4px; margin-top: 4px;">`;

                    // ‚úÖ Highlight versionNumber if it exists
                    if (item.versionNumber) {
                        tags += `<span style="font-weight: bold; font-size: 8pt; color: #333; background-color: #f4f4f4; border-radius: 3px; padding: 1px 4px; display: inline-block;">
                            ${item.versionNumber}
                        </span>`;
                    }

                    // ‚úÖ Add version release channel tag if available
                    if (item.versionReleaseChannel) {
                        const tagColors = { "major": "#4da6ff", "other": "#ca4141", "minor": "#47863e", "patch": "#ffbd2e" };
                        tags += `
                            <span style="color: #fff; font-size: 8pt; background-color: ${tagColors[item.versionReleaseChannel]}; border-radius: 3px; padding: 1px 4px; display: inline-block;">
                                ${item.versionReleaseChannel.toLowerCase()}
                            </span>`;
                    }

                    // ‚úÖ Define colors for classification categories
                    const categoryColors = {
                        securityType: "#ca4141", // Red for security-related issues
                        breakingType: "#ff9800", // Orange for breaking issues
                        componentType: "#4da6ff" // Blue for component classification
                    };

                    // ‚úÖ Function to format tag text (lowercase and remove underscores)
                    const formatTagText = text => text.toLowerCase().replace(/_/g, "");

                    // ‚úÖ Iterate over classification attributes and apply colors accordingly
                    if (item.classification) {
                        Object.keys(item.classification).forEach(category => {
                            const values = item.classification[category];

                            if (Array.isArray(values)) {
                                values.forEach(value => {
                                    if (value !== "UNKNOWN") {
                                        const tagColor = categoryColors[category] || "#6e5494"; // Default color if category not explicitly set
                                        tags += `
                                            <span style="color: #fff; font-size: 8pt; background-color: ${tagColor}; border-radius: 3px; padding: 1px 4px; display: inline-block;">
                                                ${formatTagText(value)}
                                            </span>
                                        `;
                                    }
                                });
                            }
                        });
                    }

                    let releaseUrl = (item.versionUrl && item.versionUrl.trim().startsWith("https://"))
                        ? item.versionUrl.trim()
                        : (item.versionReleaseNotes && item.versionReleaseNotes.trim().startsWith("https://"))
                            ? item.versionReleaseNotes.trim()
                            : "#";

                    let timeOnly = item.versionTimestampLastUpdate
                        ? new Date(item.versionTimestampLastUpdate).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        : "";

                    // Ensures everything stays in one row with proper spacing
                    let releaseNotesHtml = `
                        <div style="display: flex; align-items: center; gap: 6px;">
                            ${avatar}
                            <a target="_blank" href="${releaseUrl}" style="font-weight: bold; text-decoration: none; color: #007bff;">
                                ${versionLabel}
                            </a>
                            ${timeOnly ? `<span style="font-size: 0.85em; color: #666;">(${timeOnly})</span>` : ""}
                        </div>
                    `;

                    // ‚úÖ Find matching Reddit posts
                    const matchingRedditPosts = globalRedditPosts.filter(post =>
                        post.subreddit.toLowerCase() === item.versionProductName.toLowerCase()
                    );

                    let redditHtml = "";
                    if (matchingRedditPosts.length > 0) {
                        redditHtml = `<ul class="reddit-summary" style="list-style: none; padding-left: 0; font-size: 10pt; color: #777;">`;

                        matchingRedditPosts.forEach(post => {
                            const postDate = timeAgo(post.created_utc);

                            // Check if classification.componentType exists, is an array, and is not empty
                            let predictedType = post.classification && Array.isArray(post.classification.componentType) && post.classification.componentType.length > 0
                                ? post.classification.componentType.filter(type => type.toLowerCase() !== "unknown").map(type => `<span style="display: inline-block; background: #4da6ff; color: white; padding: 2px 6px; margin: 2px; border-radius: 4px; font-size: 8pt;">${type.toLowerCase()}</span>`).join(" ")
                                : `<span style="color: #888; font-size: 8pt;">N/A</span>`; // Default value if no classification is available

                            // Check if classification.securityType exists and add styling
                            let securityType = post.classification && Array.isArray(post.classification.securityType) && post.classification.securityType.length > 0
                                ? post.classification.securityType.filter(type => type.toLowerCase() !== "unknown").map(type => `<span style="display: inline-block; background: #ca4141; color: white; padding: 2px 6px; margin: 2px; border-radius: 4px; font-size: 8pt;">${type.toLowerCase()}</span>`).join(" ")
                                : `<span style="color: #888; font-size: 8pt;">N/A</span>`;

                            // Check if classification.breakingType exists and add styling
                            let breakingType = post.classification && Array.isArray(post.classification.breakingType) && post.classification.breakingType.length > 0
                                ? post.classification.breakingType.filter(type => type.toLowerCase() !== "unknown").map(type => `<span style="display: inline-block; background: #ff9800; color: white; padding: 2px 6px; margin: 2px; border-radius: 4px; font-size: 8pt;">${type.toLowerCase()}</span>`).join(" ")
                                : `<span style="color: #888; font-size: 8pt;">N/A</span>`;

                            redditHtml += `
                                <div style="display: flex; align-items: flex-start; gap: 6px; margin-bottom: 8px; font-size: 9pt; color: #555;">
                                    <img src="./img/reddit-icon.svg" alt="Reddit" style="width: 14px; height: 14px; margin-top: 3px; opacity: 0.7;">
                                    <div>
                                        <a href="${post.url}" target="_blank" style="color: #0079d3; text-decoration: none; font-size: 9pt;">
                                            ${post.title}
                                        </a>
                                        <div style="color: #888; font-size: 8pt; margin-top: 2px;">
                                            ${postDate} | ‚ñ≤ ${post.score} | üí¨ ${post.num_comments} | Posted by u/${post.author}
                                        </div>
                                        <div style="color: #888; font-size: 8pt; margin-top: 2px;">
                                            üè∑Ô∏è <strong>Predicted Type:</strong> ${predictedType}
                                        </div>
                                        <div style="color: #888; font-size: 8pt; margin-top: 2px;">
                                            üîí <strong>Security Type:</strong> ${securityType}
                                        </div>
                                        <div style="color: #888; font-size: 8pt; margin-top: 2px;">
                                            ‚ö†Ô∏è <strong>Breaking Type:</strong> ${breakingType}
                                        </div>
                                    </div>
                                </div>`;
                        });
                        redditHtml += `</ul>`;
                    }

                    let versionResource = item._id
                        ? `
                    <div style="width: 100%; margin: 4px 0px; font-size: 9pt; color: #555; display: block;">
                        <div>
                            <a href="https://releasetrain.io/api/v/${item._id}" target="_blank" style="color: #888; text-decoration: none; font-size: 9pt;">
                                ID: ${item._id}
                            </a>
                        </div>
                    </div>`
                        : "";

                    htmlBuffer += `
                    <li class="versionListClassSection-item">
                        ${releaseNotesHtml}
                        ${tags} 
                        ${versionResource}
                        ${redditHtml}
                    </li>`;
                });

                htmlBuffer += `</ul></details>`;
            });

            $(".versionListClassSection").html(htmlBuffer); // ‚úÖ Efficient bulk UI update

            // ‚úÖ Update the charts
            drawTimeSeriesChart({ labels: Object.keys(dailyCounts), counts: Object.values(dailyCounts) });
            drawUpdateTypeChart(updateCounts);
            drawComponentTypeChart(componentTypeCounts);
            drawCveChart(cveCounts);
        }

        function getLast7Days(dailyCounts) {
            const today = new Date();
            let last7Days = [];

            for (let i = 6; i >= 0; i--) {
                let date = new Date(today);
                date.setDate(today.getDate() - i);

                // Convert date to YYYYMMDD format using local time
                let yyyymmdd = `${date.getFullYear()}${String(date.getMonth() + 1).padStart(2, "0")}${String(date.getDate()).padStart(2, "0")}`;

                // Ensure the last 7 days are always populated, even if missing from `dailyCounts`
                let count = dailyCounts.hasOwnProperty(yyyymmdd) ? dailyCounts[yyyymmdd] : 0;

                last7Days.push({
                    original: yyyymmdd, // Keep the original format for reference
                    count: count // Use existing count or default to 0
                });
            }

            return last7Days; // Always ensures exactly 7 elements with continuous dates
        }

        function formatDateForList(yyyymmdd) {
            const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

            let year = yyyymmdd.slice(0, 4);
            let monthIndex = parseInt(yyyymmdd.slice(4, 6)) - 1;
            let day = parseInt(yyyymmdd.slice(6, 8));

            let dateObj = new Date(year, monthIndex, day);
            if (isNaN(dateObj.getTime())) return "Invalid Date";

            const today = new Date();
            const yesterday = new Date();
            yesterday.setDate(today.getDate() - 1);

            if (dateObj.toDateString() === today.toDateString()) return "Today";
            if (dateObj.toDateString() === yesterday.toDateString()) return "Yesterday";

            return `${dayNames[dateObj.getDay()]}, ${months[monthIndex]} ${day}, ${year}`;
        }

        function formatDateForGraphs(yyyymmdd) {
            const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const dayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

            // Ensure input is valid and exactly 8 characters long
            if (!yyyymmdd || yyyymmdd.length !== 8 || isNaN(yyyymmdd)) {
                console.warn(`Invalid date input: ${yyyymmdd}`);
                return "Invalid Date";
            }

            let year = parseInt(yyyymmdd.slice(0, 4), 10);
            let monthIndex = parseInt(yyyymmdd.slice(4, 6), 10) - 1;
            let day = parseInt(yyyymmdd.slice(6, 8), 10);

            let dateObj = new Date(year, monthIndex, day);

            // Check if date conversion is valid
            if (isNaN(dateObj.getTime())) {
                console.warn(`Date conversion failed for: ${yyyymmdd}`);
                return "Invalid Date";
            }

            return `${dayNames[dateObj.getDay()]}, ${months[monthIndex]} ${day}, ${year}`;
        }

        function updateURLWithSelectedComponents() {
            const selectedComponents = $('.component-names').select2('data')
                .map(item => item.text)
                .filter(text => text.trim() !== '') // Remove empty values
                .join(',');

            let newUrl = window.location.origin + window.location.pathname;

            if (selectedComponents) {
                newUrl += `?q=${selectedComponents}`;
            }

            // ‚úÖ Remove `?q=` if empty
            window.history.replaceState({}, document.title, newUrl);
        }

        // ‚úÖ Function to update URL with selected components and refresh the page
        function updateURLWithSelectedComponents() {
            const selectedComponents = $('.component-names').select2('data')
                .map(item => item.text)
                .filter(text => text.trim() !== '') // Remove empty values
                .join(',');

            let newUrl = window.location.origin + window.location.pathname;

            if (selectedComponents) {
                newUrl += `?q=${selectedComponents}`;
            }

            // ‚úÖ Prevent unnecessary reload if URL is already correct
            if (window.location.href !== newUrl) {
                window.history.replaceState({}, document.title, newUrl);
                location.reload(); // ‚úÖ Refresh the page after updating the URL
            }
        }

        function getTodayDate() {
            $(".getTodayDate").text(new Date().toLocaleDateString());
        }

        // Function to sort versions by last update timestamp (most recent first)
        function sortByTriageLastUpdate() {
            $(".loadingClass").show(); // Show loading animation

            setTimeout(() => { // Ensure UI updates before sorting starts
                if (!cachedTriageLastUpdateData) { // If not cached, sort and store
                    let sortedData = [...versionData]; // Clone to avoid modifying original

                    sortedData.sort((a, b) => {
                        let timeA = new Date(a.versionTimestampLastUpdate).getTime();
                        let timeB = new Date(b.versionTimestampLastUpdate).getTime();

                        return timeB - timeA; // Sort most recent updates first
                    });

                    cachedTriageLastUpdateData = sortedData; // Store sorted results for Last Update
                }

                renderVersionList(cachedTriageLastUpdateData); // Use cached sorted results
                highlightActiveButton("#sortByTriageLastUpdate"); // Highlight the active button

                $(".loadingClass").fadeOut(); // Hide loading animation after sorting
            }, 50);
        }

        // Function to sort versions by triage breaking (including breakingType priority)
        function sortByTriageBreaking() {
            $(".loadingClass").show(); // Show loading animation

            setTimeout(() => { // Ensure UI updates before sorting starts
                if (!cachedTriageBreakingData) { // If not cached, sort and store
                    let sortedData = [...versionData]; // Clone to avoid modifying original

                    sortedData.sort((a, b) => {

                        // Priority: Prioritize isCve = false
                        if (a.isCve && !b.isCve) return 1;
                        if (b.isCve && !a.isCve) return -1;

                        // Priority: Move "OS" classification items to the top (case insensitive)
                        const componentPriority = ["os", "server", "language", "database", "browser"];
                        const componentNonPriority = ["app", "ide", "github", "web", "repository", "design"];

                        let priorityA = Infinity; // Default to neutral if no priority is found
                        let priorityB = Infinity; // Default to neutral if no priority is found

                        for (let i = 0; i < componentPriority.length; i++) {
                            if (Array.isArray(a.classification?.componentType) && a.classification.componentType.some(type => type.toLowerCase() === componentPriority[i])) {
                                priorityA = i; // Assign priority index if found
                            }
                            if (Array.isArray(b.classification?.componentType) && b.classification.componentType.some(type => type.toLowerCase() === componentPriority[i])) {
                                priorityB = i; // Assign priority index if found
                            }
                        }

                        let isEmptyA = !Array.isArray(a.classification?.componentType) || a.classification.componentType.length === 0; // Check if componentType is empty
                        let isEmptyB = !Array.isArray(b.classification?.componentType) || b.classification.componentType.length === 0; // Check if componentType is empty

                        if (isEmptyA && isEmptyB) {
                            priorityA = priorityB = Infinity; // Treat both as neutral if empty
                        }

                        if (isEmptyA !== isEmptyB) {
                            if (isEmptyA) priorityA = componentPriority.length; // Assign mid-priority to empty
                            if (isEmptyB) priorityB = componentPriority.length; // Assign mid-priority to empty
                        }

                        if (priorityA !== priorityB) {
                            return priorityA - priorityB; // Lower index means higher priority
                        }

                        let versionTagsA = a.versionSearchTags?.length || 0;
                        let versionTagsB = b.versionSearchTags?.length || 0;

                        if (versionTagsA !== versionTagsB && (versionTagsA < 5 || versionTagsB < 5)) {
                            return versionTagsA - versionTagsB; // Prefer fewer version tags
                        }

                        let countA = a.classification?.componentType?.length || 0;
                        let countB = b.classification?.componentType?.length || 0;
                        if (priorityA !== -1 && priorityB !== -1 && countA !== countB) {
                            return countA - countB; // Prefer fewer elements
                        }

                        let hasNonPriorityA = Array.isArray(a.classification?.componentType) && a.classification.componentType.some(type => componentNonPriority.includes(type.toLowerCase()));
                        let hasNonPriorityB = Array.isArray(b.classification?.componentType) && b.classification.componentType.some(type => componentNonPriority.includes(type.toLowerCase()));

                        if (hasNonPriorityA !== hasNonPriorityB) {
                            return hasNonPriorityA - hasNonPriorityB; // Push non-priority components lower
                        }

                        // Priority: Move "Critical Failure" to the top, then "Limited Functionality", then "Breaking Update"
                        let breakingPriority = { "Critical Failure": 3, "Limited Functionality": 2, "Breaking Update": 1 };
                        let breakingA = a.classification?.breakingType?.[0] || "";
                        let breakingB = b.classification?.breakingType?.[0] || "";
                        priorityA = breakingPriority[breakingA] || 0;
                        priorityB = breakingPriority[breakingB] || 0;
                        if (priorityA !== priorityB) return priorityB - priorityA;

                        // Priority: Move "major" release channels to the top
                        let isMajorA = a.versionReleaseChannel === "major" ? 1 : 0;
                        let isMajorB = b.versionReleaseChannel === "major" ? 1 : 0;
                        if (isMajorA !== isMajorB) return isMajorB - isMajorA;

                        // Priority: Sort by higher version number
                        let versionPartsA = a.versionNumber ? a.versionNumber.split('.').map(num => parseInt(num, 10) || 0) : [];
                        if (versionPartsA.length === 1) versionPartsA = [versionPartsA[0], 0, 0]; // Only master version exists
                        else if (versionPartsA.length === 2) versionPartsA = [versionPartsA[0], versionPartsA[1], 0]; // Master and minor exist, patch defaults to 0

                        let versionPartsB = b.versionNumber ? b.versionNumber.split('.').map(num => parseInt(num, 10) || 0) : [];
                        if (versionPartsB.length === 1) versionPartsB = [versionPartsB[0], 0, 0]; // Only master version exists
                        else if (versionPartsB.length === 2) versionPartsB = [versionPartsB[0], versionPartsB[1], 0]; // Master and minor exist, patch defaults to 0

                        let [masterA, minorA, patchA] = versionPartsA;
                        let [masterB, minorB, patchB] = versionPartsB;

                        if (masterA !== masterB) {
                            console.log(`Comparing Master: ${a.versionNumber} vs ${b.versionNumber} ‚Üí Winner: ${masterB > masterA ? b.versionNumber : a.versionNumber}`);
                            return masterB - masterA; // Higher master version wins
                        }

                        if (minorA !== minorB) {
                            console.log(`Comparing Minor: ${a.versionNumber} vs ${b.versionNumber} ‚Üí Winner: ${minorB > minorA ? b.versionNumber : a.versionNumber}`);
                            return minorB - minorA; // Higher minor version wins
                        }

                        if (patchA !== patchB) {
                            console.log(`Comparing Patch: ${a.versionNumber} vs ${b.versionNumber} ‚Üí Winner: ${patchB > patchA ? b.versionNumber : a.versionNumber}`);
                            return patchB - patchA; // Higher patch version wins
                        }

                        // Priority: Sort by most Reddit posts (subreddit matches versionProductName)
                        let redditCountA = redditPostCounts[a.versionProductName] || 0;
                        let redditCountB = redditPostCounts[b.versionProductName] || 0;
                        if (redditCountA !== redditCountB) return redditCountB - redditCountA;

                        // Priority: If both have breakingType, sort by the one with more values
                        let breakingCountA = a.classification?.breakingType?.length || 0;
                        let breakingCountB = b.classification?.breakingType?.length || 0;
                        if (breakingCountA !== breakingCountB) return breakingCountB - breakingCountA;

                        // Priority: Sort by triage (higher values first)
                        let triageA = a.triage || 0;
                        let triageB = b.triage || 0;
                        return triageB - triageA;
                    });

                    cachedTriageBreakingData = sortedData; // Store sorted results for TriageBreaking
                }

                renderVersionList(cachedTriageBreakingData); // Use cached sorted results
                highlightActiveButton("#sortByTriageBreaking"); // Highlight the active button

                $(".loadingClass").fadeOut(); // Hide loading animation after sorting
            }, 50);
        }

        // Function to sort versions by triage security (including securityType priority & version ranking)
        function sortByTriageSecurity() {
            $(".loadingClass").show(); // Show loading animation

            setTimeout(() => { // Ensure UI updates before sorting starts
                if (!cachedTriageSecurityData) { // If not cached, sort and store
                    let sortedData = [...versionData]; // Clone to avoid modifying the original

                    sortedData.sort((a, b) => {
                        // Priority 1: Prioritize isCve = true
                        if (a.isCve && !b.isCve) return -1;
                        if (b.isCve && !a.isCve) return 1;

                        // Priority 2: Sort by securityType count (more security elements = higher rank)
                        let securityCountA = a.classification?.securityType?.length || 0;
                        let securityCountB = b.classification?.securityType?.length || 0;
                        if (securityCountA !== securityCountB) return securityCountB - securityCountA;

                        // Priority 3: Sort by higher version number (only if the first part is less than 4 digits)
                        let versionA = a.versionNumber ? a.versionNumber.split('.').map(num => parseInt(num, 10)) : [];
                        let versionB = b.versionNumber ? b.versionNumber.split('.').map(num => parseInt(num, 10)) : [];

                        // Check if the first part of the version is less than 4 digits (to avoid treating years as versions)
                        if (versionA.length > 0 && versionB.length > 0 && versionA[0] < 1000 && versionB[0] < 1000) {
                            for (let i = 0; i < Math.max(versionA.length, versionB.length); i++) {
                                let numA = versionA[i] || 0;
                                let numB = versionB[i] || 0;
                                if (numA !== numB) return numB - numA; // Higher version first
                            }
                        }

                        // Priority 4: Move "major" release channels to the top (but after security-based sorting)
                        if (a.versionReleaseChannel === "major" && b.versionReleaseChannel !== "major") return -1;
                        if (b.versionReleaseChannel === "major" && a.versionReleaseChannel !== "major") return 1;

                        // Priority 5: Sort by most Reddit posts (subreddit matches versionProductName)
                        let redditCountA = redditPostCounts[a.versionProductName] || 0;
                        let redditCountB = redditPostCounts[b.versionProductName] || 0;
                        if (redditCountA !== redditCountB) return redditCountB - redditCountA;

                        // Priority 6: Move "OS" classification items to the top
                        let isOS_A = a.classification?.componentType?.includes("OS") ? 1 : 0;
                        let isOS_B = b.classification?.componentType?.includes("OS") ? 1 : 0;
                        if (isOS_A !== isOS_B) return isOS_B - isOS_A;

                        // Priority 7: Sort by triage (higher values first)
                        let triageA = a.triage || 0;
                        let triageB = b.triage || 0;
                        return triageB - triageA;
                    });

                    cachedTriageSecurityData = sortedData; // Store sorted results for TriageSecurity
                }

                renderVersionList(cachedTriageSecurityData); // Use cached sorted results
                highlightActiveButton("#sortByTriageSecurity"); // Highlight the active button

                $(".loadingClass").fadeOut(); // Hide loading animation after sorting
            }, 50);
        }

        // Function to sort versions by triage security (including securityType priority & version ranking)
        // Function to sort versions by triage security (including legal safety and privacy emphasis)
        function sortByTriageLegal() {
            $(".loadingClass").show(); // Show loading animation

            setTimeout(() => { // Ensure UI updates before sorting starts
                if (!cachedTriageLegalData) { // If not cached, sort and store
                    let sortedData = [...versionData]; // Clone to avoid modifying the original

                    sortedData.sort((a, b) => {
                        // Check for legal and privacy keywords
                        const keywords = ['legal', 'privacy', 'safety'];
                        const countKeywords = (types) => types.filter(type => keywords.some(keyword => type.includes(keyword))).length;

                        let keywordCountA = countKeywords(a.classification?.securityType || []);
                        let keywordCountB = countKeywords(b.classification?.securityType || []);

                        if (keywordCountA !== keywordCountB) {
                            return keywordCountB - keywordCountA; // Prioritize versions with more legal/privacy types
                        }

                        // Fallback to count of securityType
                        let securityCountA = a.classification?.securityType?.length || 0;
                        let securityCountB = b.classification?.securityType?.length || 0;
                        if (securityCountA !== securityCountB) {
                            return securityCountB - securityCountA; // More security elements = higher rank
                        }

                        // Further fallback, if needed (e.g., by version number or date)
                        return 0;
                    });

                    cachedTriageLegalData = sortedData; // Store sorted results for TriageSecurity
                }

                renderVersionList(cachedTriageLegalData); // Use cached sorted results
                highlightActiveButton("#sortByTriageLegal"); // Highlight the active button

                $(".loadingClass").fadeOut(); // Hide loading animation after sorting
            }, 50);
        }

        function highlightActiveButton(activeButtonId) {
            $(".btn-dark").removeClass("btn-active"); // Remove highlight from all buttons
            $(activeButtonId).addClass("btn-active"); // Highlight the clicked button
        }

        $(document).ready(function () {

            // Add placeholder elements before fetching data
            $(".versionListClassSection").html('<div class="skeleton-loader"></div><div class="skeleton-loader"></div>');

            $('.component-names').select2({
                placeholder: "Select software components", // ‚úÖ Placeholder text
                allowClear: true, // ‚úÖ Enables '√ó' to clear selection
                width: 'resolve', // ‚úÖ Adjusts width dynamically
                theme: "classic", // ‚úÖ Optional: Choose a clean theme
                minimumResultsForSearch: 1, // ‚úÖ Enable search when >1 items
            });

            getAndRenderComponentList();
            getVersionCount();
            getComponentCount();
            getRedditCount()
            getTodayDate();

            computeRedditPostCounts();

            // ‚úÖ Fetch query parameter `?q=linux,android`
            const query = new URLSearchParams(window.location.search).get("q");

            if (query) {
                componentNameParam = query;
                const queryArgs = componentNameParam.split(",");

                // ‚úÖ Clear and update dropdown with multiple components
                $(".component-names").empty();
                queryArgs.forEach((arg) => {
                    const newOption = new Option(arg, arg, true, true);
                    $(".component-names").append(newOption);
                });

                $(".component-names").trigger("change");
                getReleases();
            } else {
                getReleases(); // Load default versions if no query provided
            }

            // ‚úÖ Update URL when components change
            $(".component-names").on("change", function () {
                updateURLWithSelectedComponents();
                getReleases();
            });

            function updateURLWithSelectedComponents() {
                const selectedComponents = $(".component-names").select2("data").map(item => item.text);
                const queryString = selectedComponents.length > 0 ? `?q=${selectedComponents.join(",")}` : "";
                window.history.replaceState({}, document.title, queryString ? queryString : window.location.pathname);
            }

            // ‚úÖ Handle adding new components
            $(document).on("click", ".add-component", function () {
                const component = $(this).data("component");
                const select2Data = $(".component-names").select2("data");

                if (!select2Data.some(item => item.text === component)) {
                    const newOption = new Option(component, component, true, true);
                    $(".component-names").append(newOption).trigger("change");
                }
            });

            // ‚úÖ Handle removing components
            $(document).on("click", ".remove-component", function () {
                const component = $(this).data("component");
                const select2Data = $(".component-names").select2("data");
                const newData = select2Data.filter(item => item.text !== component);

                $(".component-names").val(newData.map(item => item.id)).trigger("change");
            });

            // ‚úÖ Interactive LLM Chat Integration
            $("#sendChat").click(function () {
                const message = $("#chatInput").val().trim();
                if (!message) return;
                $("#chatWindow").append("<div><strong>You:</strong> " + message + "</div>");
                $("#chatInput").val("");

                $.ajax({
                    url: "https://your-llm-api.example.com/chat",
                    method: "POST",
                    data: JSON.stringify({ prompt: message }),
                    contentType: "application/json",
                    success: function (response) {
                        $("#chatWindow").append("<div><strong>LLM:</trong> " + response.answer + "</div>");
                        $("#chatWindow").scrollTop($("#chatWindow")[0].scrollHeight);
                    },
                    error: function () {
                        $("#chatWindow").append("<div><em>Error communicating with the chat service.</em></div>");
                    }
                });
            });

            // ‚úÖ Handle pressing "Enter" to send chat
            $("#chatInput").keypress(function (e) {
                if (e.which === 13) {
                    $("#sendChat").click();
                }
            });

            const toggleButton = document.querySelector('.toggle-button');
            if (toggleButton) {
                toggleButton.addEventListener('click', function () {
                    const leftColumn = document.querySelector('.left-column');
                    leftColumn.classList.toggle('closed');
                    this.textContent = leftColumn.classList.contains('closed') ? 'Open' : 'Close';
                });
            }
        });

        function drawCveChart(data) {
            const canvasId = "cveChart";

            // Remove existing canvas if present (to allow re-rendering)
            $("#" + canvasId).remove();
            $("#graphSection2").append(`<canvas id="${canvasId}" style="max-height: 250px;"></canvas>`);

            const ctx = document.getElementById(canvasId).getContext("2d");

            new Chart(ctx, {
                type: "bar",
                data: {
                    labels: ["CVE", "Other"],
                    datasets: [{
                        label: "CVE vs Other",
                        data: [data.cve, data.other],
                        backgroundColor: ["#ff6384", "#36a2eb"],
                        borderColor: ["#ff6384", "#36a2eb"],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        yAxes: [{
                            ticks: {
                                beginAtZero: true,
                                fontColor: "#d1d5db"
                            },
                            gridLines: {
                                color: "#444"
                            }
                        }],
                        xAxes: [{
                            ticks: {
                                fontColor: "#d1d5db"
                            },
                            gridLines: {
                                color: "#444"
                            }
                        }]
                    },
                    legend: {
                        labels: {
                            fontColor: "#d1d5db"
                        }
                    }
                }
            });
        }

        document.addEventListener("DOMContentLoaded", () => {
            const buttons = document.querySelectorAll(".sort-buttons button");

            function setActiveButton(selectedButton) {
                buttons.forEach(button => button.classList.remove("active")); // Remove active from all
                selectedButton.classList.add("active"); // Add active to selected button
            }

            document.getElementById("sortByTriageLastUpdate").addEventListener("click", function () {
                setActiveButton(this);
                sortByTriageLastUpdate();
            });

            document.getElementById("sortByTriageBreaking").addEventListener("click", function () {
                setActiveButton(this);
                sortByTriageBreaking();
            });

            document.getElementById("sortByTriageSecurity").addEventListener("click", function () {
                setActiveButton(this);
                sortByTriageSecurity();
            });

            document.getElementById("sortByTriageLegal").addEventListener("click", function () {
                setActiveButton(this);
                sortByTriageLegal();
            });


            // Ensure the default selected button (sortByTriageLastUpdate) is activated on load
            setActiveButton(document.getElementById("sortByTriageLastUpdate"));
        });

    </script>
    <script src="./lib/googleanalytics.js"></script>
</body>

</html>